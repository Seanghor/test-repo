<!doctype html>
<html lang="km">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+Khmer:wght@400;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/remixicon@4.8.0/fonts/remixicon.css"
      rel="stylesheet"
    />

    <title>Chlat Kids Sudoku</title>
    <style>
      :root {
        --bg: #e9f6ff;
        --ink: #0b2239;
        --muted: #4b647a;
        --brand: #1a8cff;
        --brand2: #31c48d;
        --warn: #ffb020;
        --shadow: 0 14px 30px rgba(10, 30, 60, 0.12);
        --radius: 10px;
        --gap: 8px;
        --font:
          "Noto Sans Khmer", system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
        --cell: 56px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: var(--font);
        color: var(--ink);
        background:
          radial-gradient(
            1200px 600px at 20% 0%,
            rgba(26, 140, 255, 0.18),
            transparent 60%
          ),
          radial-gradient(
            900px 500px at 90% 10%,
            rgba(49, 196, 141, 0.16),
            transparent 60%
          ),
          var(--bg);
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }

      .wrap {
        width: min(1100px, 100%);
        padding: 16px 14px 22px;
      }

      header {
        display: flex;
        align-items: end;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }

      @media (max-width: 520px) {
        header {
          align-items: start;
          flex-direction: column;
        }
      }

      .brand {
        display: flex;
        justify-content: space-between;
        align-items: start;
        gap: 12px;
        user-select: none;
        width: 100%;
        margin-bottom: 2rem;
      }
      .game-config {
        display: flex;
        gap: 20px;
      }

      .game-config > .title {
        text-align: center;
        font-size: 12px;
      }
      .game-config > .title > #level_string {
        font-size: 16px;
        color: #4fb3ff;
      }

      .headerButtons {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .title h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.2px;
      }

      .title p {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 13px;
      }

      .top-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      button,
      select {
        font-family: var(--font);
      }

      button {
        border: 0;
        /* border-radius: 10px; */
        padding: 10px 10px;
        background: #fff;
        color: var(--ink);
        border: 1px solid rgba(20, 60, 110, 0.08);
        cursor: pointer;
        transition:
          transform 0.08s ease,
          box-shadow 0.18s ease;
        touch-action: manipulation;
      }

      button:active {
        transform: translateY(1px) scale(0.99);
        box-shadow: 0 6px 12px rgba(10, 30, 60, 0.1);
      }

      button.pause {
        display: flex;
        align-items: center;
        font-size: 24px;
        font-weight: bold;
        text-shadow:
          0.5px 0 currentColor,
          -0.5px 0 currentColor;
        background: #fab907;
        color: #000000;
        border: 0;
        font-weight: 400;
        border-radius: 7px;
      }

      .actionPause {
        color: #fab907;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }

      button.new {
        display: flex;
        align-items: center;
        font-size: 24px;
        text-shadow:
          0.5px 0 currentColor,
          -0.5px 0 currentColor;
        background: #02e002;
        color: #000000;
        border: 0;
        font-weight: 400;
        border-radius: 7px;
      }

      .actionNew {
        color: #02e002;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }

      button.primary {
        background: linear-gradient(135deg, var(--brand), #4fb3ff);
        color: #fff;
        border: 0;
      }

      button.success {
        background: linear-gradient(135deg, var(--brand2), #61e2b7);
        color: #08301f;
        border: 0;
        font-weight: 800;
        display: flex;
        justify-content: center;
        gap: 4px;
        align-items: center;
      }

      button.warn {
        background: linear-gradient(135deg, #ffd37a, #ffb020);
        color: #4a2b00;
        border: 0;
        font-weight: 800;
        display: flex;
        justify-content: center;
        gap: 4px;
        max-height: 32px;
        align-items: center;
      }

      button.ghost {
        display: flex;
        justify-content: center;
        gap: 4px;
        max-height: 32px;
        align-items: center;
        background: transparent;
        box-shadow: none;
        border: 1px dashed rgba(11, 34, 57, 0.25);
        color: var(--muted);
      }

      button.pillbtn {
        border-radius: 999px;
        padding: 6px 12px;
        box-shadow: none;
        border: 1px solid rgba(11, 34, 57, 0.1);
        background: rgba(255, 255, 255, 0.8);
        font-weight: 800;
        color: var(--muted);
        display: flex;
        justify-content: center;
        gap: 4px;
        min-height: 42px;
        align-items: center;
      }

      button.pillbtn.active {
        background: #fff;
        color: var(--ink);
        box-shadow: 0 10px 18px rgba(10, 30, 60, 0.1);
      }

      button#btnWinNext,
      button#btnWinClose {
        padding: 5px 10px;
        border-radius: 5px;
      }

      button#btnWinNext {
        color: #fff;
      }

      .btn-hint-container {
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        width: fit-content;
        gap: 4px;
      }
      .btn-hint-container > button {
        width: fit-content;
        border-radius: 7px;
        font-weight: 400;
        max-height: 40px;
      }
      .btn-hint-container > button > i {
        font-size: 20px;
      }

      .divider-line::after {
        content: "";
        position: absolute;
        width: 2px;
        height: var(--line-h);
        background: #000000;
        right: -8px;
        top: -14px;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      @media (min-width: 940px) {
        .grid {
          align-items: start;
        }
      }

      .card {
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgb(0 0 0 / 18%);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 20px 16px;
      }

      .hud {
        width: 100%;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      .pill {
        background: rgba(26, 140, 255, 0.08);
        color: #094f8f;
        border: 1px solid rgba(26, 140, 255, 0.18);
        border-radius: 999px;
        padding: 4px 12px;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 8px;
        user-select: none;
        min-height: 42px;
      }

      .pill strong {
        font-size: 14px;
      }

      .board-wrap {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }

      .board-container {
        display: flex;
        flex-direction: column;
        width: 100%;
      }

      .board {
        width: fit-content;
        border-radius: 22px;
        box-shadow: 0 10px 24px rgba(10, 30, 60, 0.12);
        margin: auto;
        min-height: 242px;
      }

      .board-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
      }
      .board-header div {
        text-align: center;
      }
      .keypadBox {
        margin-top: 4rem;
      }
      .label {
        color: #585858;
        font-size: 12px;
      }
      .value {
        font-size: 14px;
        font-weight: 600;
      }
      .game-name {
        font-size: 20px;
        font-weight: 700;
      }
      .value.mistake {
        color: red;
      }

      .cells {
        display: grid;
        touch-action: manipulation;
        border-top: 2px solid black;
        border-left: 2px solid black;
        position: relative;
      }

      .cells::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;

        /* change these based on your group size */
        --thick: 2px;
        --step: calc(100% / var(--group)); /* each block width */
        z-index: 50;
        background:
    /* vertical lines */
          repeating-linear-gradient(
            to right,
            transparent 0,
            transparent calc(var(--step) - var(--thick)),
            #000 calc(var(--step) - var(--thick)),
            #000 var(--step)
          ),
          /* horizontal lines */
          repeating-linear-gradient(
              to bottom,
              transparent 0,
              transparent calc(var(--step) - var(--thick)),
              #000 calc(var(--step) - var(--thick)),
              #000 var(--step)
            );
      }

      .cell {
        width: var(--cell);
        height: var(--cell);
        border-left: 1px solid #bdbdbd;
        border-bottom: 1px solid #bdbdbd;
        background: #fff;
        display: grid;
        place-items: center;
        font-size: 20px;
        font-weight: 600;
        cursor: pointer;
        user-select: none;
        transition:
          transform 0.08s ease,
          border-color 0.12s ease,
          background 0.12s ease;
        position: relative;
      }

      .cell:active {
        transform: scale(0.99);
      }

      .cell.given {
        background: rgba(81, 87, 85, 0.158);
        /* border-color: rgba(49, 196, 141, 0.25); */
        color: #000000;
        cursor: default;
      }

      .cell.selected {
        border: 2px solid;
        border-color: rgb(26 140 255 / 50%) !important;
        background: rgba(26, 140, 255, 0.1);
        color: rgb(57 163 255);
      }

      .cell.conflict {
        color: red;
        /* border-color: rgba(255, 77, 77, 0.65); */
        background: rgba(255, 77, 77, 0.08);
      }

      .cell.same {
        background: rgba(26, 140, 255, 0.05);
      }

      .cell.hint {
        animation: hintPulse 0.6s ease 2;
      }

      @keyframes hintPulse {
        0% {
          transform: scale(1);
        }

        50% {
          transform: scale(1.03);
        }

        100% {
          transform: scale(1);
        }
      }

      .keypadBox {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      /* LEFT */
      .left-panel {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      /* RIGHT (rounded container) */
      .right-panel {
        border-radius: 10px;
        border: 2px solid rgb(29 74 114 / 22%);
        /* padding: 12px; */
        overflow: hidden;
        box-shadow: 0 2px 0px rgb(201 201 201 / 54%);
        border-bottom: 0;
      }

      /* keypad grid */
      .keypad {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .keypad {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 1px;
        overflow: hidden;
      }

      .keypad button {
        padding: 10px 16px;
        font-size: 14px;
        font-weight: 600;
    
        /* max-width: 40px; */

        /* border-radius: 0px; */
        /* border-radius: 16px; */
      }

      .keypad button.small {
        font-size: 14px;
        font-weight: 800;
        color: var(--muted);
        /* background: rgba(204, 44, 44, 0.9); */
      }

      /* .keypad > button:first-child {
        border-top-left-radius: 8px;
      } */
      /* .keypad > button:nth-child(5) {
        border-top-right-radius: 8px;
      } */
      /* .keypad > button:nth-child(6) {
        border-bottom-left-radius: 8px;
      } */
      /* .keypad > button:last-child {
        border-bottom-right-radius: 8px;
      } */

      .mini {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.45;
      }

      .right {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .frog {
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }

      .frog-face {
        width: 60px;
        height: 60px;
        border-radius: 22px;
        background: linear-gradient(
          145deg,
          rgba(49, 196, 141, 0.35),
          rgba(49, 196, 141, 0.18)
        );
        border: 1px solid rgba(49, 196, 141, 0.35);
        box-shadow: 0 10px 20px rgba(10, 30, 60, 0.1);
        display: grid;
        place-items: center;
        flex: 0 0 auto;
      }

      .frog-face span {
        font-size: 30px;
        filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.08));
      }

      .frog-msg {
        flex: 1;
        background: rgba(255, 255, 255, 0.85);
        border: 1px solid rgba(20, 60, 110, 0.1);
        border-radius: 18px;
        padding: 12px;
        box-shadow: 0 10px 20px rgba(10, 30, 60, 0.08);
        position: relative;
      }

      .frog-msg:before {
        content: "";
        position: absolute;
        left: -7px;
        top: 18px;
        width: 14px;
        height: 14px;
        background: rgba(255, 255, 255, 0.85);
        border-left: 1px solid rgba(20, 60, 110, 0.1);
        border-bottom: 1px solid rgba(20, 60, 110, 0.1);
        transform: rotate(45deg);
      }

      .frog-msg h3 {
        margin: 0 0 6px;
        font-size: 14px;
      }

      .frog-msg p {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
        line-height: 1.35;
      }

      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
      }

      .switch {
        display: inline-flex;
        background: rgba(11, 34, 57, 0.06);
        border: 1px solid rgba(11, 34, 57, 0.1);
        padding: 5px;
        border-radius: 999px;
        gap: 6px;
      }

      .switch button {
        box-shadow: none;
        border: 0;
        background: transparent;
        padding: 8px 10px;
        border-radius: 999px;
        font-size: 13px;
        color: var(--muted);
        font-weight: 900;
        cursor: pointer;
        justify-content: center;
        gap: 4px;
        max-height: 32px;
        align-items: center;
      }

      .switch button.active {
        background: #fff;
        color: var(--ink);
        box-shadow: 0 8px 16px rgba(10, 30, 60, 0.1);
      }

      .modeBar {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: flex-start;
        margin-top: 4px;
      }

      .lvlBox {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        padding: 10px;
        border-radius: 16px;
        background: rgba(26, 140, 255, 0.06);
        border: 1px solid rgba(26, 140, 255, 0.16);
        width: 100%;
        margin-bottom: 6px;
      }

      .lvlLeft {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .lvlLabel {
        font-weight: 900;
        color: var(--ink);
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      select:disabled {
        opacity: 0.6;
        box-shadow: none;
        background: rgba(255, 255, 255, 0.75);
      }

      .toast {
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(20, 60, 110, 0.12);
        box-shadow: 0 16px 30px rgba(10, 30, 60, 0.16);
        padding: 10px 12px;
        border-radius: 14px;
        display: flex;
        gap: 10px;
        align-items: center;
        max-width: min(560px, calc(100% - 26px));
        opacity: 0;
        pointer-events: none;
        transition:
          opacity 0.2s ease,
          transform 0.2s ease;
        z-index: 50;
      }

      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-2px);
      }

      .toast .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: var(--brand2);
        box-shadow: 0 0 0 6px rgba(49, 196, 141, 0.18);
      }

      .toast .txt {
        font-size: 13px;
        color: var(--ink);
        font-weight: 900;
      }

      .modal {
        position: fixed;
        inset: 0;
        background: rgba(8, 20, 35, 0.45);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 60;
        padding: 18px;
      }

      .modal.show {
        display: flex;
      }

      .modalCard {
        width: min(560px, 100%);
        background: rgba(255, 255, 255, 0.95);
        border-radius: 22px;
        border: 1px solid rgba(255, 255, 255, 0.6);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.22);
        padding: 16px;
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .confetti {
        position: absolute;
        inset: -40px -40px auto -40px;
        height: 140px;
        background:
          radial-gradient(
            circle at 10% 50%,
            rgba(26, 140, 255, 0.35),
            transparent 35%
          ),
          radial-gradient(
            circle at 35% 70%,
            rgba(49, 196, 141, 0.35),
            transparent 35%
          ),
          radial-gradient(
            circle at 65% 40%,
            rgba(255, 176, 32, 0.35),
            transparent 35%
          ),
          radial-gradient(
            circle at 85% 75%,
            rgba(255, 77, 77, 0.28),
            transparent 35%
          );
        opacity: 0.9;
      }

      .stars {
        font-size: 26px;
        margin: 6px 0 4px;
        letter-spacing: 2px;
      }

      .modalCard h2 {
        margin: 6px 0 8px;
        font-size: 18px;
      }

      .modalCard p {
        margin: 0 0 12px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.4;
      }

      .modalActions {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
      }

      .loading {
        position: fixed;
        inset: 0;
        background: rgba(8, 20, 35, 0.35);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 80;
        padding: 18px;
      }

      .loading.show {
        display: flex;
      }

      .loadingBox {
        width: min(420px, 100%);
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.65);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.2);
        padding: 16px;
        text-align: center;
      }

      .spinner {
        width: 34px;
        height: 34px;
        border-radius: 50%;
        border: 4px solid rgba(11, 34, 57, 0.1);
        border-top-color: rgba(26, 140, 255, 0.65);
        margin: 6px auto 10px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 380px) {
        :root {
          --cell: 52px;
          --gap: 7px;
        }

        .keypad button {
          padding: 12px 8px;
        }

        select {
          min-width: 140px;
        }
      }

      select {
        border-radius: 14px;
        padding: 10px 12px;
        border: 1px solid rgba(11, 34, 57, 0.14);
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 10px 18px rgba(10, 30, 60, 0.08);
        font-weight: 900;
        color: var(--ink);
        min-width: 100px;
        outline: none;
      }
      #boardSize {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;

        padding: 8px 36px 8px 12px;
        font-size: 16px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: white;

        /* Custom arrow */
        background-image: url("data:image/svg+xml;charset=US-ASCII,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16'><polygon points='0,0 16,0 8,8' fill='%23999'/></svg>");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 16px;

        cursor: pointer;

        /* important: dropdown should appear over other content */
        z-index: 10;
        position: relative;
      }
      #boardSize:hover {
        border-color: #888;
      }
      #boardSize:focus {
        outline: none;
        border-color: #555;
        box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
      }

      /* @Difficulty */
      .difficulty-tabs {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 13px;
        user-select: none;
        flex-wrap: wrap;
        margin-bottom: 24px;
      }

      .difficulty-tabs .label {
        color: var(--muted);
        font-weight: 600;
      }

      .difficulty-tabs .tab {
        background: transparent;
        border: 0;
        padding: 4px 4px;
        font-weight: 500;
        font-size: 13px;
        color: #6f6d6d;
        cursor: pointer;
        position: relative;
      }

      .difficulty-tabs .tab::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        bottom: -4px;
        height: 2px;
        background: transparent;
        border-radius: 2px;
        transition: background 0.2s ease;
      }

      button.tab {
        transition: all 0.5s;
        border-radius: 3px;
      }
      button.tab:active {
        transform: none;
        box-shadow: none;
        background-color: #5858582b;
      }

      .difficulty-tabs .tab.active {
        color: #1a8cff;
      }

      .difficulty-tabs .tab.active::after {
        background: #1a8cff;
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <header>
        <div class="brand">
          <div class="headerButtons">
            <div class="actionPause">
              <button class="pause" id="btnPause" type="button">
                <i class="ri-pause-large-fill"></i>
              </button>
              <span id="t_pause">Pause</span>
            </div>
            <div class="actionNew">
              <button class="new" id="btnNew" type="button">
                <i class="ri-reset-right-fill"></i>
              </button>
              <span id="t_new">New</span>
            </div>
          </div>

          <select id="boardSize">
            <option value="4">4 Ã— 4</option>
            <option value="6">6 Ã— 6</option>
            <option value="9">9 Ã— 9</option>
          </select>
        </div>
      </header>

      <div class="grid">
        <section class="card board-wrap">
          <div class="board-container">
            <div>
              <div class="board-header">
                <div class="game-name">Soduku</div>
                <div>
                  <div class="label" id="t_mistakes">Mistakes</div>
                  <div class="value mistake" id="mistakes">0</div>
                </div>
                <div>
                  <div class="label" id="t_times">Time</div>
                  <div class="value" id="times">3:12</div>
                </div>
              </div>
            </div>

            <!-- difficulty -->
            <div class="difficulty-tabs">
              <span class="label">Difficulty:</span>
              <button class="tab active" data-level="easy">Easy</button>
              <button class="tab" data-level="normal">Normal</button>
              <button class="tab" data-level="hard">Hard</button>
            </div>

            <!-- <div class="title">
              <div>Difficulty</div>
              <div id="level_string">Easy</div>
            </div> -->
            <div
              class="board"
              role="application"
              id="cells_container"
              aria-label="Sudoku board"
            >
              <div class="cells" id="cells"></div>
            </div>

            <!-- KEYPAD -->
            <div class="keypadBox">
              <!-- LEFT SIDE -->
              <div class="btn-hint-container">
                <!-- hint -->
                <button class="warn" id="btnHint" type="button">
                  <i class="ri-lightbulb-ai-line"></i>
                </button>
                <span id="t_hint">Hint</span>
              </div>

              <!-- RIGHT SIDE -->
              <div class="right-panel">
                <div class="keypad" id="keypad"></div>
              </div>
            </div>
          </div>
        </section>
      </div>
    </div>

    <div class="toast" id="toast" role="status" aria-live="polite">
      <div class="dot"></div>
      <div class="txt" id="toastText">Saved âœ…</div>
    </div>

    <div class="modal" id="winModal" aria-hidden="true">
      <div class="modalCard" role="dialog" aria-modal="true" aria-label="Win">
        <div class="confetti" aria-hidden="true"></div>
        <div class="stars" id="winStars">ðŸŒŸðŸŒŸðŸŒŸ</div>
        <h2 id="winTitle">Great job! ðŸŽ‰</h2>
        <p id="winText">You solved it.</p>
        <div class="modalActions">
          <button class="success" id="btnWinNext" type="button">
            <span id="t_next">Next</span>
          </button>
          <button id="btnWinClose" type="button">
            <span id="t_close">Close</span>
          </button>
        </div>
      </div>
    </div>

    <div class="loading" id="loading" aria-hidden="true">
      <div class="loadingBox">
        <div class="spinner" aria-hidden="true"></div>
        <div style="font-weight: 900; margin-bottom: 6px" id="t_loading">
          Creating puzzleâ€¦
        </div>
        <div class="mini" id="t_loading2">Please wait a moment.</div>
      </div>
    </div>

    <script>
      (() => {
        const I18N = {
          km: {
            app: "Chlat Kids Sudoku",
            sub: "áž€áž˜áŸ’ážšáž·áž + áž”áž‰áŸ’áž áž¶áž”áŸ’ážšáž…áž¶áŸ†ážáŸ’áž„áŸƒ â€” Khmer-first",
            pause: "áž•áŸ’áž¢áž¶áž€",
            reset: "áž€áŸ†ážŽážáŸ‹áž¡áž¾áž„ážœáž·áž‰",
            times: "ážšáž™áŸˆáž–áŸáž›",
            hint: "áž‡áž½áž™áž”áž“áŸ’ážáž·áž…",
            new: "áž›áŸ’áž”áŸ‚áž„ážáŸ’áž˜áž¸",
            mode: "ážšáž”áŸ€áž”",
            free: "áž€áž˜áŸ’ážšáž·ážážŸáŸážšáž¸",
            daily: "áž”áŸ’ážšáž…áž¶áŸ†ážáŸ’áž„áŸƒ",
            progress: "áž€áž¶ážšážšáž¸áž€áž…áž˜áŸ’ážšáž¾áž“",
            mistakes: "ážáž»ážŸ",
            streak: "ážŸáŸ’áž‘áŸ’ážšáž¸áž€",
            sound: "ážŸáž˜áŸ’áž›áŸáž„",
            level: "áž€áž˜áŸ’ážšáž·áž",
            go: "áž‘áŸ…",
            tip: "ážŸáž¼áž˜áž…áž»áž…áž”áŸ’ážšáž¢áž”áŸ‹áž–ážŽáŸŒážŸ ážšáž½áž…áž‡áŸ’ážšáž¾ážŸáž›áŸážáŸ” áž”áŸ’ážšáž¢áž”áŸ‹áž”áŸƒážáž„ áž‚ážºážáŸážšáŸ”",
            rules:
              "áž…áŸ’áž”áž¶áž”áŸ‹áŸ– áž‡áž½ážšážŠáŸáž€/áž‡áž½ážšážˆážš áž˜áž·áž“áž¢áž¶áž…áž˜áž¶áž“áž›áŸážážŠáž¼áž…áž‚áŸ’áž“áž¶áŸ” áž”áŸ’ážšáž¢áž”áŸ‹ (Box) áž€áŸážŠáž¼áž…áž‚áŸ’áž“áž¶áŸ”",
            integration1: "áž”áŸ’ážšáž¾áž”áž¶áž“áž€áŸ’ážšáŸ…áž¢áŸŠáž¸áž“áž’ážºážŽáž·ážáŸ–",
            integration2: "WebView áž–áŸážáŸŒáž˜áž¶áž“áŸ–",
            frogTitle: "ážŸáž½ážŸáŸ’ážáž¸! ážáŸ’áž‰áž»áŸ†áž‚ážº â€œáž†áŸ’áž›áž¶ážâ€ ðŸ¸",
            frogBase: "áž€áž»áŸ†áž²áŸ’áž™áž›áŸážážŠáž¼áž…áž‚áŸ’áž“áž¶ áž“áŸ…áž‡áž½ážšážŠáŸáž€/áž‡áž½ážšážˆážš/BoxáŸ” áž¢áŸ’áž“áž€áž¢áž¶áž…áž’áŸ’ážœáž¾áž”áž¶áž“!",
            frogSelect: "áž…áž»áž…áž”áŸ’ážšáž¢áž”áŸ‹ážŸáž·áž“ áž‘áž¾áž”áž”áž‰áŸ’áž…áž¼áž›áž›áŸážáž”áž¶áž“áŸ”",
            frogGood: "áž›áŸ’áž¢ážŽáž¶ážŸáŸ‹! áž”áž“áŸ’ážáž‘áŸ…áž‘áŸ€áž! ðŸŒŸ",
            frogOops: "áž¢áž¼áž áŸâ€¦ áž˜áž¶áž“áž›áŸážážŠáž¼áž…áž‚áŸ’áž“áž¶ ðŸ˜… ážŸáž¶áž€áž›áŸ’áž”áž„áž˜áŸ’ážáž„áž‘áŸ€áž!",
            frogHint: "áž“áŸáŸ‡áž‡áž¶áž‡áŸ†áž“áž½áž™ážáž¼áž…áŸ— ðŸ’¡",
            frogDaily: "ážáŸ’áž„áŸƒáž“áŸáŸ‡áž˜áž¶áž“áž”áž‰áŸ’áž áž¶áž–áž·ážŸáŸážŸ! ážŸáž¶áž€áž›áŸ’áž”áž„ážˆáŸ’áž“áŸ‡ážŸáŸ’áž‘áŸ’ážšáž¸áž€ ðŸ”¥",
            toastSaved: "áž”áž¶áž“ážšáž€áŸ’ážŸáž¶áž‘áž»áž€ âœ…",
            toastReset: "áž”áž¶áž“áž€áŸ†ážŽážáŸ‹áž¡áž¾áž„ážœáž·áž‰ â†»",
            toastNew: "áž”áž¶áž“áž…áž¶áž”áŸ‹áž•áŸ’ážáž¾áž˜ážáŸ’áž˜áž¸ âœ¨",
            toastHintNone: "áž‚áŸ’áž˜áž¶áž“áž€áž“áŸ’áž›áŸ‚áž„ážŸáž˜áŸ’ážšáž¶áž”áŸ‹áž‡áŸ†áž“áž½áž™áž‘áŸ ðŸ˜„",
            toastLocked: "áž€áž˜áŸ’ážšáž·ážáž“áŸáŸ‡áž“áŸ…ážáŸ‚áž…áž¶áž€áŸ‹ážŸáŸ„ ðŸ”’",
            toastDailyDone: "ážáŸ’áž„áŸƒáž“áŸáŸ‡áž”áž¶áž“áž”áž‰áŸ’áž…áž”áŸ‹ážšáž½áž…áž áž¾áž™ âœ…",
            winTitle: "áž¢ážŸáŸ’áž…áž¶ážšáŸ’áž™! áž¢áŸ’áž“áž€ážˆáŸ’áž“áŸ‡à¹à¸¥à¹‰à¸§! ðŸŽ‰",
            winTextFree: "áž¢áŸ’áž“áž€áž”áž¶áž“ážˆáŸ’áž“áŸ‡áž€áž˜áŸ’ážšáž·ážáž“áŸáŸ‡áŸ” áž€áž˜áŸ’ážšáž·ážáž”áž“áŸ’áž‘áž¶áž”áŸ‹áž”áž¶áž“áž”áž¾áž€!",
            winTextDaily: "áž¢áŸ’áž“áž€áž”áž¶áž“ážˆáŸ’áž“áŸ‡ Daily Challenge! ážŸáŸ’áž‘áŸ’ážšáž¸áž€áž€áž¾áž“áž¡áž¾áž„ ðŸ”¥",
            close: "áž”áž·áž‘",
            next: "áž”áž“áŸ’áž‘áž¶áž”áŸ‹",
            today: "ážáŸ’áž„áŸƒáž“áŸáŸ‡",
            erase: "áž›áž»áž”",
            check: "áž–áž·áž“áž·ážáŸ’áž™",
            loading: "áž€áŸ†áž–áž»áž„áž”áž„áŸ’áž€áž¾ážáž›áŸ’áž”áŸ‚áž„â€¦",
            loading2: "ážŸáž¼áž˜ážšáž„áŸ‹áž…áž¶áŸ†áž”áž“áŸ’ážáž·áž…áŸ”",
            modeFreeLabel: "ážŸáŸážšáž¸",
            modeDailyLabel: "áž”áŸ’ážšáž…áž¶áŸ†ážáŸ’áž„áŸƒ",
          },
          en: {
            app: "Chlat Kids Sudoku",
            sub: "Levels + Daily Challenge â€” Khmer-first UI",
            pause: "Pause",
            reset: "Reset",
            times: "Times",
            hint: "Hint",
            new: "New",
            mode: "Mode",
            free: "Free Levels",
            daily: "Daily Challenge",
            progress: "Progress",
            mistakes: "Mistakes",
            streak: "Streak",
            sound: "Sound",
            level: "Level",
            go: "Play",
            tip: "Tip: Tap a white box, then choose a number. Green boxes are fixed.",
            rules: "Rules: No repeats in a row, column, or box.",
            integration1: "Offline ready:",
            integration2: "WebView tip:",
            frogTitle: "Hi! Iâ€™m â€œChlatâ€ ðŸ¸",
            frogBase: "No repeats in row/column/box. You can do it!",
            frogSelect: "Tap a cell first.",
            frogGood: "Nice! Keep going! ðŸŒŸ",
            frogOops: "Oopsâ€¦ duplicate number ðŸ˜… Try again!",
            frogHint: "Hereâ€™s a tiny hint ðŸ’¡",
            frogDaily: "Today is special! Win to keep your streak ðŸ”¥",
            toastSaved: "Saved âœ…",
            toastReset: "Reset â†»",
            toastNew: "New puzzle âœ¨",
            toastHintNone: "No hint spot ðŸ˜„",
            toastLocked: "That level is locked ðŸ”’",
            toastDailyDone: "Already completed today âœ…",
            winTitle: "Great job! You win! ðŸŽ‰",
            winTextFree: "You cleared the level. Next level unlocked!",
            winTextDaily: "You beat the Daily Challenge! Streak increased ðŸ”¥",
            close: "Close",
            next: "Next",
            today: "Today",
            erase: "Erase",
            check: "Check",
            loading: "Creating puzzleâ€¦",
            loading2: "Please wait a moment.",
            modeFreeLabel: "Free",
            modeDailyLabel: "Daily",
          },
        };

        // Sound
        const Sound = (() => {
          let enabled = true;
          let ctx = null;

          function beep(
            freq = 520,
            duration = 0.08,
            type = "sine",
            gain = 0.05,
          ) {
            if (!enabled) return;
            try {
              ctx =
                ctx || new (window.AudioContext || window.webkitAudioContext)();
              const o = ctx.createOscillator();
              const g = ctx.createGain();
              o.type = type;
              o.frequency.value = freq;
              g.gain.value = gain;
              o.connect(g);
              g.connect(ctx.destination);
              o.start();
              o.stop(ctx.currentTime + duration);
            } catch (e) {}
          }
          function good() {
            beep(660, 0.08, "triangle", 0.06);
            setTimeout(() => beep(880, 0.09, "triangle", 0.05), 90);
          }
          function bad() {
            beep(180, 0.1, "sawtooth", 0.05);
          }
          function tap() {
            beep(520, 0.05, "sine", 0.03);
          }
          return {
            toggle() {
              enabled = !enabled;
              return enabled;
            },
            get enabled() {
              return enabled;
            },
            tap,
            good,
            bad,
          };
        })();

        // RNG helpers
        function mulberry32(seed) {
          let t = seed >>> 0;
          return function () {
            t += 0x6d2b79f5;
            let x = t;
            x = Math.imul(x ^ (x >>> 15), x | 1);
            x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
            return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
          };
        }
        function hashStringToSeed(str) {
          let h = 2166136261 >>> 0;
          for (let i = 0; i < str.length; i++) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
          }
          return h >>> 0;
        }
        function shuffle(arr, rnd = Math.random) {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(rnd() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        // Sudoku engine (4/6/9)
        const ENGINE = {
          config(size) {
            if (size === 4)
              return { N: 4, boxR: 2, boxC: 2, symbols: [1, 2, 3, 4] };
            if (size === 6)
              return { N: 6, boxR: 2, boxC: 3, symbols: [1, 2, 3, 4, 5, 6] };
            return {
              N: 9,
              boxR: 3,
              boxC: 3,
              symbols: [1, 2, 3, 4, 5, 6, 7, 8, 9],
            };
          },
          emptyGrid(N) {
            return Array.from({ length: N }, () => Array(N).fill(0));
          },
          canPlace(grid, r, c, val, cfg) {
            const { N, boxR, boxC } = cfg;
            for (let i = 0; i < N; i++) {
              if (grid[r][i] === val) return false;
              if (grid[i][c] === val) return false;
            }
            const br = Math.floor(r / boxR) * boxR;
            const bc = Math.floor(c / boxC) * boxC;
            for (let rr = br; rr < br + boxR; rr++) {
              for (let cc = bc; cc < bc + boxC; cc++) {
                if (grid[rr][cc] === val) return false;
              }
            }
            return true;
          },
          findBestCell(grid, cfg) {
            const { N, symbols } = cfg;
            let best = null;
            for (let r = 0; r < N; r++) {
              for (let c = 0; c < N; c++) {
                if (grid[r][c] !== 0) continue;
                const cand = [];
                for (const v of symbols) {
                  if (this.canPlace(grid, r, c, v, cfg)) cand.push(v);
                }
                if (cand.length === 0) return { r, c, candidates: [] };
                if (!best || cand.length < best.candidates.length) {
                  best = { r, c, candidates: cand };
                  if (cand.length === 1) return best;
                }
              }
            }
            return best;
          },
          solve(grid, cfg, rnd = Math.random) {
            const pick = this.findBestCell(grid, cfg);
            if (!pick) return true;
            const { r, c, candidates } = pick;
            if (candidates.length === 0) return false;
            const order = shuffle(candidates.slice(), rnd);
            for (const v of order) {
              grid[r][c] = v;
              if (this.solve(grid, cfg, rnd)) return true;
              grid[r][c] = 0;
            }
            return false;
          },
          countSolutions(grid, cfg, limit = 2) {
            let count = 0;
            const dfs = () => {
              if (count >= limit) return;
              const pick = this.findBestCell(grid, cfg);
              if (!pick) {
                count++;
                return;
              }
              const { r, c, candidates } = pick;
              if (candidates.length === 0) return;
              for (const v of candidates) {
                grid[r][c] = v;
                dfs();
                grid[r][c] = 0;
                if (count >= limit) return;
              }
            };
            dfs();
            return count;
          },
          makeSolution(cfg, rnd = Math.random) {
            const g = this.emptyGrid(cfg.N);
            this.solve(g, cfg, rnd);
            return g;
          },
          clone(grid) {
            return grid.map((r) => r.slice());
          },
          makePuzzleFromSolution(
            solution,
            cfg,
            givensTarget,
            uniqueness = true,
            rnd = Math.random,
          ) {
            const N = cfg.N;
            const puzzle = this.clone(solution);
            const pos = [];
            for (let r = 0; r < N; r++)
              for (let c = 0; c < N; c++) pos.push([r, c]);
            shuffle(pos, rnd);
            let toRemove = Math.max(0, N * N - givensTarget);

            let attempts = 0;
            const maxAttempts = N * N * 7;
            for (
              let i = 0;
              i < pos.length && toRemove > 0 && attempts < maxAttempts;
              i++
            ) {
              attempts++;
              const [r, c] = pos[i];
              const backup = puzzle[r][c];
              if (backup === 0) continue;
              puzzle[r][c] = 0;

              if (uniqueness) {
                const test = this.clone(puzzle);
                const cnt = this.countSolutions(test, cfg, 2);
                if (cnt !== 1) {
                  puzzle[r][c] = backup;
                  continue;
                }
              } else {
                const test = this.clone(puzzle);
                const ok = this.solve(test, cfg, rnd);
                if (!ok) {
                  puzzle[r][c] = backup;
                  continue;
                }
              }
              toRemove--;
            }
            return puzzle;
          },
          conflicts(grid, cfg) {
            const N = cfg.N;
            const out = Array.from({ length: N }, () => Array(N).fill(false));
            for (let r = 0; r < N; r++) {
              for (let c = 0; c < N; c++) {
                const v = grid[r][c];
                if (v === 0) continue;
                grid[r][c] = 0;
                const ok = this.canPlace(grid, r, c, v, cfg);
                grid[r][c] = v;
                if (!ok) out[r][c] = true;
              }
            }
            return out;
          },
          isSolved(grid, solution, cfg) {
            for (let r = 0; r < cfg.N; r++) {
              for (let c = 0; c < cfg.N; c++) {
                if (grid[r][c] !== solution[r][c]) return false;
              }
            }
            return true;
          },
        };

        // #Levels
        function levelToSpec(size, difficulty = "easy", levelIndex = 1) {
          if (![4, 6, 9].includes(size)) size = 4;
          if (!["easy", "normal", "hard"].includes(difficulty))
            difficulty = "easy";

          const levels = DIFFICULTY_GIVENS[size][difficulty];

          if (levelIndex < 1 || levelIndex > levels.length) levelIndex = 1;

          const givens = levels[levelIndex - 1];
          const label = `${size}Ã—${size} â€¢ ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} â€¢ Level ${levelIndex}`;

          return {
            size,
            label,
            givens,
            uniqueness: true,
            levelIndex,
            difficulty,
          };
        }

        // --> #Handel save store
        function saveProgress() {
          const progress = {
            currentSize,
            currentDifficulty,
            currentLevelIndex,
          };
          localStorage.setItem("sudokuProgress", JSON.stringify(progress));
        }
        function loadProgress() {
          const progress = JSON.parse(localStorage.getItem("sudokuProgress"));
          if (progress) {
            currentSize = progress.currentSize || 4;
            currentDifficulty = progress.currentDifficulty || "easy";
            currentLevelIndex = progress.currentLevelIndex || 1;
          }
        }

        function updateLevelStringFromSpec(level, spec) {
          el.textContent = `â€¢`;
          //   el.textContent = `Level ${level} â€¢ ${spec.label} â€¢ ${difficulty}`;
        }

        function updateLevelString() {
          const el = document.getElementById("level_string");
          if (!el) return;

          const spec = levelToSpec(
            currentSize,
            currentDifficulty,
            currentLevelIndex,
          );
          el.textContent = spec.label;
        }

        // Storage
        const STORE_KEY = "chlat_sudoku_allinone_v2";
        const STREAK_KEY = "chlat_sudoku_daily_streak_v2";
        const $ = (q) => document.querySelector(q);
        function loadStore() {
          try {
            const r = localStorage.getItem(STORE_KEY);
            return r ? JSON.parse(r) : null;
          } catch (e) {
            return null;
          }
        }
        function saveStore(o) {
          try {
            localStorage.setItem(STORE_KEY, JSON.stringify(o));
          } catch (e) {}
        }
        function todayKey() {
          const d = new Date();
          return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(
            2,
            "0",
          )}-${String(d.getDate()).padStart(2, "0")}`;
        }
        function loadStreak() {
          try {
            const r = localStorage.getItem(STREAK_KEY);
            return r
              ? JSON.parse(r)
              : { streak: 0, lastDay: null, completedDay: null };
          } catch (e) {
            return { streak: 0, lastDay: null, completedDay: null };
          }
        }
        function saveStreak(o) {
          try {
            localStorage.setItem(STREAK_KEY, JSON.stringify(o));
          } catch (e) {}
        }

        const el = {
          // t_app: $("#t_app"),
          t_pause: $("#t_pause"),
          // t_reset: $("#t_reset"),
          t_hint: $("#t_hint"),
          t_new: $("#t_new"),
          t_mode: $("#t_mode"),
          t_free: $("#t_free"),
          t_daily: $("#t_daily"),
          t_progress: $("#t_progress"),
          t_mistakes: $("#t_mistakes"),
          t_times: $("#t_times"),
          t_streak: $("#t_streak"),
          t_sound: $("#t_sound"),
          t_levelLabel: $("#t_levelLabel"),
          t_go: $("#t_go"),
          t_next: $("#t_next"),
          t_close: $("#t_close"),
          t_loading: $("#t_loading"),
          t_loading2: $("#t_loading2"),

          modeLabel: $("#modeLabel"),
          progress: $("#progress"),
          mistakes: $("#mistakes"),
          times: $("#times"),
          streak: $("#streak"),
          cells: $("#cells"),
          keypad: $("#keypad"),
          levelInfo: $("#levelInfo"),
          levelSelectBox: $("#levelSelectBox"),
          levelSelect: $("#levelSelect"),
          btnGoLevel: $("#btnGoLevel"),
          tip: $("#tip"),
          rules: $("#rules"),
          integration: $("#integration"),
          frogEmoji: $("#frogEmoji"),
          frogTitle: $("#frogTitle"),
          frogText: $("#frogText"),

          btnPause: $("#btnPause"),
          // btnReset: $("#btnReset"),
          btnHint: $("#btnHint"),
          btnNew: $("#btnNew"),
          btnFree: $("#btnFree"),
          btnDaily: $("#btnDaily"),
          btnSound: $("#btnSound"),
          btnKM: $("#btnKM"),
          btnEN: $("#btnEN"),
          toast: $("#toast"),
          toastText: $("#toastText"),
          winModal: $("#winModal"),
          winStars: $("#winStars"),
          winTitle: $("#winTitle"),
          winText: $("#winText"),
          btnWinNext: $("#btnWinNext"),
          btnWinClose: $("#btnWinClose"),
          loading: $("#loading"),
        };

        // State
        const DIFFICULTY_GIVENS = {
          4: {
            easy: [10, 10, 11, 10, 9, 10, 11, 10, 10, 9, 10, 11, 10, 10, 10],
            normal: [8, 8, 9, 8, 7, 8, 9, 8, 8, 7, 8, 9, 8, 8, 8],
            hard: [6, 6, 7, 6, 5, 6, 7, 6, 6, 5, 6, 7, 6, 6, 6],
          },
          6: {
            easy: [20, 21, 19, 20, 21, 20, 20, 21, 19, 20, 20, 21, 20, 20, 21],
            normal: [
              16, 17, 15, 16, 17, 16, 16, 17, 15, 16, 16, 17, 16, 16, 17,
            ],
            hard: [12, 13, 11, 12, 13, 12, 12, 13, 11, 12, 12, 13, 12, 12, 13],
          },
          9: {
            easy: [34, 35, 33, 34, 36, 34, 35, 33, 34, 35, 34, 36, 34, 35, 33],
            normal: [
              28, 29, 27, 28, 30, 28, 29, 27, 28, 29, 28, 30, 28, 29, 27,
            ],
            hard: [24, 25, 23, 24, 26, 24, 25, 23, 24, 25, 24, 26, 24, 25, 23],
          },
        };

        // Current state
        let initialStore = loadStore();
        let currentSize = 4;
        let currentDifficulty = "easy";
        let currentLevelIndex = initialStore
          ? initialStore.progress?.levelIndex
          : 1;
        let lang = "en";
        let level = initialStore ? initialStore.progress?.levelIndex : 1;
        let mode = "free";

        // ----- LEVEL SPEC -----
        function levelToSpec(
          size = currentSize,
          difficulty = currentDifficulty,
          levelIndex = currentLevelIndex,
        ) {
          if (![4, 6, 9].includes(size)) size = 4;
          if (!["easy", "normal", "hard"].includes(difficulty))
            difficulty = "easy";

          const levels = DIFFICULTY_GIVENS[size][difficulty];
          levelIndex = Math.max(1, Math.min(levelIndex, levels.length));

          return {
            size,
            difficulty,
            levelIndex,
            givens: levels[levelIndex - 1],
            uniqueness: true,
            label: `${size}Ã—${size} â€¢ ${difficulty.toUpperCase()} â€¢ Level ${levelIndex}/15`,
          };
        }

        let cfg = ENGINE.config(4);
        let solution = null;
        let puzzle = null;
        let grid = null;

        // IMPORTANT: fixed naming (no shadowing)
        let givensMask = null;

        let selected = { r: -1, c: -1 };
        let mistakes = 0;
        let lastSelectedVal = 0;

        function toast(msg) {
          el.toastText.textContent = msg;
          el.toast.classList.add("show");
          clearTimeout(toast._t);
          toast._t = setTimeout(() => el.toast.classList.remove("show"), 1200);
        }
        function showLoading(on) {
          el.loading.classList.toggle("show", !!on);
          el.loading.setAttribute("aria-hidden", on ? "false" : "true");
        }
        function setCellSizeFor(N) {
          let cell = 56;
          if (N === 4) cell = 64;
          if (N === 6) cell = 56;
          if (N === 9) cell = 40;
          if (window.innerWidth < 460) {
            if (N === 9) cell = 36;
            if (N === 6) cell = 52;
            if (N === 4) cell = 60;
          }
          document.documentElement.style.setProperty("--cell", `${cell}px`);
          document.documentElement.style.setProperty(
            "--gap",
            N === 9 ? "6px" : "8px",
          );
        }

        function frogSay(kind) {
          const T = I18N[lang];
          if (kind === "good") {
            // el.frogEmoji.textContent = "ðŸ¸";
            // el.frogText.textContent = T.frogGood;
          } else if (kind === "oops") {
            // el.frogEmoji.textContent = "ðŸ˜…";
            // el.frogText.textContent = T.frogOops;
          } else if (kind === "select") {
            el.frogEmoji.textContent = "ðŸ‘‰";
            el.frogText.textContent = T.frogSelect;
          } else if (kind === "hint") {
            el.frogEmoji.textContent = "ðŸ’¡";
            el.frogText.textContent = T.frogHint;
          } else if (kind === "daily") {
            el.frogEmoji.textContent = "ðŸŒž";
            el.frogText.textContent = T.frogDaily;
          } else {
            // el.frogEmoji.textContent = "ðŸ¸";
            // el.frogText.textContent = T.frogBase;
          }
        }

        function applyLang() {
          const T = I18N[lang];
          // el.t_app.textContent = T.app;
          el.t_pause.textContent = T.pause;
          // el.t_reset.textContent = T.reset;
          el.t_hint.textContent = T.hint;
          el.t_new.textContent = T.new;
          //   el.t_mode.textContent = T.mode;
          //   el.t_free.textContent = T.free;
          //   el.t_daily.textContent = T.daily;
          //   el.t_progress.textContent = T.progress;
          el.t_mistakes.textContent = T.mistakes;
          el.t_times.textContent = T.times;
          //   el.t_streak.textContent = T.streak;
          //   el.t_sound.textContent = T.sound;
          //   el.t_levelLabel.textContent = "ðŸŽšï¸ " + T.level;
          //   el.t_go.textContent = T.go;
          // el.tip.textContent = T.tip;
          // el.rules.textContent = T.rules;
          // el.integration.innerHTML = `<b>${T.integration1}</b> Single-file HTML. Uses <code>localStorage</code>.<br><br><b>${T.integration2}</b> Load as local asset in WebView.`;
          el.t_close.textContent = T.close;
          el.t_next.textContent = T.next;
          el.t_loading.textContent = T.loading;
          el.t_loading2.textContent = T.loading2;
          // el.frogTitle.textContent = T.frogTitle;

          el.btnKM?.classList.toggle("active", lang === "km");
          el.btnEN?.classList.toggle("active", lang === "en");
          //   el.modeLabel.textContent =
          //     mode === "free" ? T.modeFreeLabel : T.modeDailyLabel;
          //   el.btnSound.innerHTML =
          //     (Sound.enabled ? "ðŸ”Š " : "ðŸ”‡ ") + `<span>${T.sound}</span>`;

          //   el.levelSelect.disabled = mode !== "free";
          //   el.btnGoLevel.disabled = mode !== "free";
          //   el.levelSelectBox.style.opacity = mode !== "free" ? "0.6" : "1";
        }

        function computeProgress() {
          const N = cfg.N;
          let filled = 0;
          for (let r = 0; r < N; r++)
            for (let c = 0; c < N; c++) if (grid[r][c] !== 0) filled++;
          return `${filled}/${N * N}`;
        }
        function updateHUD() {
          //   el.progress.textContent = grid ? computeProgress() : "0/0";
          el.mistakes.textContent = String(mistakes);
          //   el.streak.textContent = String(loadStreak().streak || 0);
          //   el.modeLabel.textContent =
          //     mode === "free"
          //       ? I18N[lang].modeFreeLabel
          //       : I18N[lang].modeDailyLabel;
        }

        // function buildKeypad() {
        //   const N = cfg.N;
        //   el.keypad.innerHTML = "";
        //   el.keypad.style.gridTemplateColumns = `repeat(5, 1fr) `;
        //   for (let i = 1; i <= N; i++) {
        //     const b = document.createElement("button");
        //     b.className = "primary";
        //     b.textContent = String(i);
        //     b.addEventListener("click", () => setValue(i));
        //     el.keypad.appendChild(b);
        //   }
        //   const bErase = document.createElement("button");
        //   bErase.className = "small";
        //   bErase.innerHTML = `âŒ« `;
        //   bErase.addEventListener("click", eraseValue);
        //   el.keypad.appendChild(bErase);
        // }

        function buildKeypad() {
          el.keypad.innerHTML = "";

          const N = cfg.N; // â† source of truth (4, 6, or 9)

          for (let n = 1; n <= N; n++) {
            const btn = document.createElement("button");
            btn.textContent = n;
            btn.className = "primary";
            btn.addEventListener("click", () => setValue(n));
            el.keypad.appendChild(btn);
          }

          // space
          const spaceBtn = document.createElement("button");
          spaceBtn.style.pointerEvents = "none";
          if (N === 6) el.keypad.appendChild(spaceBtn);

          // erase button
          const erase = document.createElement("button");
          erase.textContent = "âŒ«";
          erase.className = "key erase";
          erase.addEventListener("click", eraseValue);
          el.keypad.appendChild(erase);
          el.keypad.sty;
          el.keypad.style.gridTemplateColumns = `repeat(${N === 4 ? 5 : N === 6 ? 4 : 5}, 1fr)`;
        }

        function getUnlockedLevel() {
          const store = loadStore();
          return store?.free?.unlockedLevel || 1;
        }
        function setUnlockedLevel(val) {
          const store = loadStore() || {};
          store.free = store.free || {};
          store.free.unlockedLevel = Math.max(
            store.free.unlockedLevel || 1,
            val,
          );
          saveStore(store);
        }

        function buildLevelSelect() {
          const unlocked = getUnlockedLevel();
          //   el.levelSelect.innerHTML = "";
          for (let i = 1; i <= 100; i++) {
            const spec = levelToSpec(i);
            const opt = document.createElement("option");
            opt.value = String(i);
            const lock = i > unlocked;
            opt.textContent = lock
              ? `ðŸ”’ Level ${i} (${spec.label})`
              : `ðŸƒ Level ${i} (${spec.label})`;
            opt.disabled = lock;
            // el.levelSelect.appendChild(opt);
          }
          //   el.levelSelect.value = String(Math.min(level, unlocked));
        }

        function buildBoard() {
          if (!grid || !givensMask) return; // safety
          const N = cfg.N;
          setCellSizeFor(N);
          el.cells.innerHTML = "";
          el.cells.style.gridTemplateColumns = `repeat(${N}, var(--cell))`;

          const conflicts = ENGINE.conflicts(grid, cfg);

          for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
              const d = document.createElement("div");
              d.className = "cell";
              d.dataset.r = r;
              d.dataset.c = c;

              const atBoxRight = (c + 1) % cfg.boxC === 0 && c !== N - 1;
              const atBoxBottom = (r + 1) % cfg.boxR === 0 && r !== N - 1;
              if (atBoxRight) {
                // d.style.borderRight = "4px solid black";
              }
              if (atBoxBottom) {
                // d.style.borderBottom = "4px solid black";
              }

              if (givensMask[r][c]) d.classList.add("given");
              const v = grid[r][c];
              d.textContent = v === 0 ? "" : String(v);
              if (conflicts[r][c]) d.classList.add("conflict");

              d.addEventListener("click", () => {
                if (givensMask[r][c]) {
                  Sound.tap();
                  return;
                }
                selectCell(r, c);
                Sound.tap();
              });

              el.cells.appendChild(d);
            }
          }

          //const cells = N * N;
          // const container = document.getElementById('cells_container');
          // const cells = document.querySelectorAll('#cells .cell.given');
          // cells[1].style.setProperty('--line-h', `${container.clientHeight}px`);
          // cells[1].classList.add('divider-line')
          const cellPerBlock = N % 2 === 0 ? 2 : 3;
          el.cells.style.setProperty("--n", N);
          el.cells.style.setProperty("--group", cellPerBlock);
          renderSelectionHighlights();
        }

        function getCellEl(r, c) {
          return el.cells.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
        }
        function selectCell(r, c) {
          selected = { r, c };
          lastSelectedVal = grid[r][c] || 0;
          renderSelectionHighlights();
        }
        function clearSelection() {
          selected = { r: -1, c: -1 };
          lastSelectedVal = 0;
          renderSelectionHighlights();
        }
        function renderSelectionHighlights() {
          if (!grid) return;
          const N = cfg.N;
          const conflicts = ENGINE.conflicts(grid, cfg);
          for (let r = 0; r < N; r++) {
            for (let c = 0; c < N; c++) {
              const node = getCellEl(r, c);
              if (!node) continue;
              node.classList.toggle(
                "selected",
                selected.r === r && selected.c === c,
              );
              node.classList.toggle("conflict", conflicts[r][c]);
              const v = grid[r][c];
              node.textContent = v === 0 ? "" : String(v);
              const same = lastSelectedVal !== 0 && v === lastSelectedVal;
              node.classList.toggle(
                "same",
                same &&
                  !(selected.r === r && selected.c === c) &&
                  !node.classList.contains("given"),
              );
            }
          }
        }

        function setValue(val) {
          if (selected.r < 0) {
            frogSay("select");
            Sound.bad();
            return;
          }
          const { r, c } = selected;
          if (givensMask[r][c]) return;

          grid[r][c] = val;
          lastSelectedVal = val;

          const conflicts = ENGINE.conflicts(grid, cfg);
          if (conflicts[r][c]) {
            mistakes++;
            frogSay("oops");
            Sound.bad();
          } else {
            frogSay("good");
            Sound.good();
          }

          renderSelectionHighlights();
          updateHUD();
          persist();

          if (ENGINE.isSolved(grid, solution, cfg)) onWin();
        }

        function eraseValue() {
          if (selected.r < 0) {
            frogSay("select");
            Sound.bad();
            return;
          }
          const { r, c } = selected;
          if (givensMask[r][c]) return;
          grid[r][c] = 0;
          lastSelectedVal = 0;
          Sound.tap();
          frogSay();
          renderSelectionHighlights();
          updateHUD();
          persist();
        }

        function checkBoard() {
          const conflicts = ENGINE.conflicts(grid, cfg);
          let any = false;
          for (let r = 0; r < cfg.N; r++)
            for (let c = 0; c < cfg.N; c++) if (conflicts[r][c]) any = true;
          if (any) {
            mistakes++;
            frogSay("oops");
            Sound.bad();
          } else {
            frogSay("good");
            Sound.good();
          }
          renderSelectionHighlights();
          updateHUD();
          persist();
        }

        function hint() {
          const empties = [];
          for (let r = 0; r < cfg.N; r++) {
            for (let c = 0; c < cfg.N; c++) {
              if (givensMask[r][c]) continue;
              if (grid[r][c] === 0) empties.push([r, c]);
            }
          }
          if (!empties.length) {
            toast(I18N[lang].toastHintNone);
            Sound.tap();
            return;
          }
          const [r, c] = empties[Math.floor(Math.random() * empties.length)];
          grid[r][c] = solution[r][c];
          const node = getCellEl(r, c);
          if (node) node.classList.add("hint");
          setTimeout(() => node && node.classList.remove("hint"), 700);

          frogSay("hint");
          Sound.tap();
          selectCell(r, c);
          renderSelectionHighlights();
          updateHUD();
          persist();

          if (ENGINE.isSolved(grid, solution, cfg)) onWin();
        }

        function setLevel(size, difficulty, levelIndex) {
          currentSize = size;
          currentDifficulty = difficulty;
          currentLevelIndex = levelIndex;

          const spec = levelToSpec(size, difficulty, levelIndex);

          generateAndStartPuzzle({
            size: spec.size,
            givensTarget: spec.givens,
            uniqueness: true,
            seed: null,
          });

          updateLevelString();
          saveProgress();
        }

        function nextLevel() {
          currentLevelIndex++;
          if (currentLevelIndex > 15) currentLevelIndex = 1; // loop
          setLevel(currentSize, currentDifficulty, currentLevelIndex);
        }

        function startPuzzle() {
          setLevel(currentSize, currentDifficulty, currentLevelIndex);
        }

        function switchMode(newMode) {
          mode = newMode;
          el.btnFree.classList.toggle("active", mode === "free");
          el.btnDaily.classList.toggle("active", mode === "daily");
          applyLang();

          if (mode === "daily") {
            frogSay("daily");
            startDaily();
          } else {
            frogSay();
            buildLevelSelect();
            const store = loadStore();
            const last = store?.free?.currentLevel || 1;
            setLevel(last);
          }
          updateHUD();
          persist();
        }

        function startDaily() {
          const s = loadStreak();
          const tk = todayKey();
          const alreadyDone = s.completedDay === tk;

          const streakVal = s.streak || 0;

          const givensTarget = size === 4 ? 10 : size === 6 ? 20 : 34;
          const seed = hashStringToSeed("chlat-daily-" + tk + "-size" + size);

          el.levelInfo.textContent = `${I18N[lang].today} â€¢ ${size}Ã—${size} â€¢ Daily`;
          generateAndStartPuzzle({
            size,
            givensTarget,
            uniqueness: true,
            seed,
          });

          if (alreadyDone) toast(I18N[lang].toastDailyDone);
        }

        // âœ… FIXED: NO SHADOWING, ALWAYS CREATES grid + givensMask BEFORE rendering
        function generateAndStartPuzzle({
          size,
          givensTarget,
          uniqueness,
          seed,
        }) {
          showLoading(true);

          setTimeout(() => {
            cfg = ENGINE.config(size);
            buildKeypad();
            mistakes = 0;
            selected = { r: -1, c: -1 };
            lastSelectedVal = 0;
            resetTimer();
            startTimer();

            const rnd = seed != null ? mulberry32(seed) : Math.random;

            let sol = null;
            const maxTries = size === 9 ? 6 : 4;

            for (let t = 0; t < maxTries; t++) {
              const s = ENGINE.makeSolution(cfg, rnd);
              const puz = ENGINE.makePuzzleFromSolution(
                s,
                cfg,
                givensTarget,
                uniqueness,
                rnd,
              );
              const test = ENGINE.clone(puz);
              const ok = ENGINE.solve(test, cfg, rnd);
              if (ok) {
                sol = s;
                puzzle = puz;
                break;
              }
            }
            if (!sol) {
              sol = ENGINE.makeSolution(cfg, rnd);
              puzzle = ENGINE.makePuzzleFromSolution(
                sol,
                cfg,
                givensTarget,
                false,
                rnd,
              );
            }

            solution = sol;
            grid = ENGINE.clone(puzzle);
            givensMask = puzzle.map((row) => row.map((v) => v !== 0)); // âœ… global mask

            applyLang();
            buildKeypad();
            buildBoard(); // âœ… now always has grid + givensMask
            updateHUD();
            persist();

            showLoading(false);
          }, 250);
        }

        function computeStars() {
          if (mistakes === 0) return 3;
          if (mistakes <= 2) return 2;
          return 1;
        }

        function onWin() {
          stopTimer();
          paused = true;

          const T = I18N[lang];
          el.winStars.textContent = "ðŸŒŸ".repeat(computeStars());
          el.winTitle.textContent = T.winTitle;

          if (mode === "free") {
            el.winText.textContent = T.winTextFree;
          } else {
            el.winText.textContent = T.winTextDaily;
            const tk = todayKey();
            const s = loadStreak();
            if (s.completedDay !== tk) {
              const d = new Date();
              const y = new Date(d);
              y.setDate(d.getDate() - 1);
              const yk = `${y.getFullYear()}-${String(
                y.getMonth() + 1,
              ).padStart(2, "0")}-${String(y.getDate()).padStart(2, "0")}`;
              s.streak = s.lastDay === yk ? (s.streak || 0) + 1 : 1;
              s.lastDay = tk;
              s.completedDay = tk;
              saveStreak(s);
            }
          }

          el.winModal.classList.add("show");
          el.winModal.setAttribute("aria-hidden", "false");
          Sound.good();
          updateHUD();
          persist();
        }

        function closeWin() {
          el.winModal.classList.remove("show");
          el.winModal.setAttribute("aria-hidden", "true");
          frogSay("good");
        }
        function goNextAfterWin() {
          closeWin();

          if (mode === "free") {
            let next = currentLevelIndex + 1;

            if (next > 15) {
              next = 1; // loop inside same difficulty
            }

            currentLevelIndex = next;
            setLevel(currentSize, currentDifficulty, currentLevelIndex);
          } else {
            startDaily();
          }
        }

        function resetPuzzle() {
          grid = ENGINE.clone(puzzle);
          mistakes = 0;
          selected = { r: -1, c: -1 };
          lastSelectedVal = 0;
          frogSay();
          buildBoard();
          updateHUD();
          persist();
          toast(I18N[lang].toastReset);
        }

        function newPuzzle() {
          if (mode === "daily") {
            startDaily();
            toast(I18N[lang].toastNew);
            return;
          }

          const spec = levelToSpec(currentSize, currentDifficulty); // âœ… pass size + difficulty
          generateAndStartPuzzle({
            size: spec.size,
            givensTarget: spec.givens,
            uniqueness: spec.uniqueness,
            seed: null,
          });

          toast(I18N[lang].toastNew);
        }

        function persist() {
          const store = loadStore() || {};
          console.log("store:", store);

          // Global settings
          store.lang = lang;
          store.sound = Sound.enabled;
          store.mode = mode || "free";

          // âœ… SAVE PROGRESS (NEW SYSTEM)
          store.progress = {
            size: currentSize,
            difficulty: currentDifficulty,
            levelIndex: currentLevelIndex,
          };

          // âœ… SAVE CURRENT SESSION
          store.session = {
            cfgN: cfg.N,
            solution,
            puzzle,
            grid,
            givensMask,
            mistakes,
            timeSeconds,
            dateKey: todayKey(),
          };

          saveStore(store);
          //   toast(I18N[lang].toastSaved);
        }

        function restore() {
          const store = loadStore();
          console.log("store :: ", store);

          if (!store) return false;

          lang = store.lang || "en";
          if (
            typeof store.sound === "boolean" &&
            store.sound !== Sound.enabled
          ) {
            Sound.toggle();
          }
          mode = store.mode || "free";

          // âœ… RESTORE PROGRESS (NEW SYSTEM)
          if (store.progress) {
            currentSize = store.progress.size || 4;
            currentDifficulty = store.progress.difficulty || "easy";
            currentLevelIndex = store.progress.levelIndex || 1;
          } else {
            currentSize = 4;
            currentDifficulty = "easy";
            currentLevelIndex = 1;
          }
        }

        // -- handle times:
        let timeSeconds = 0;
        let timerId = null;
        function formatTime(sec) {
          const m = Math.floor(sec / 60);
          const s = sec % 60;
          return `${m}:${String(s).padStart(2, "0")}`;
        }

        function updateTimeUI() {
          if (el.times) {
            el.times.textContent = formatTime(timeSeconds);
          }
        }

        function startTimer() {
          stopTimer();
          timerId = setInterval(() => {
            timeSeconds++;
            updateTimeUI();
          }, 1000);
        }

        function stopTimer() {
          if (timerId) {
            clearInterval(timerId);
            timerId = null;
          }
        }

        function pauseTimer() {
          stopTimer();
        }

        function resumeTimer() {
          startTimer();
        }

        function resetTimer() {
          timeSeconds = 0;
          updateTimeUI();
        }

        let paused = false;
        function handlePause() {
          paused = !paused;

          el.cells.classList.toggle("paused", paused);
          el.keypad.classList.toggle("paused", paused);

          el.btnPause.innerHTML = paused
            ? `<i class="ri-play-large-fill"></i>`
            : `<i class="ri-pause-large-fill"></i>`;

          el.t_pause.textContent = paused ? I18N[lang].go : I18N[lang].pause;

          if (paused) pauseTimer();
          else resumeTimer();

          Sound.tap();
        }

        // - #Handle Grid
        const SUPPORTED_SIZES = [4, 6, 9];
        document.getElementById("boardSize").addEventListener("change", (e) => {
          const newSize = Number(e.target.value);

          // reset level when size changes
          currentSize = newSize;
          currentDifficulty = "easy";
          currentLevelIndex = 1;

          setLevel(currentSize, currentDifficulty, currentLevelIndex);
          toast(`Board size changed to ${newSize} Ã— ${newSize}`);
        });

        // - #Handle Difficulty
        document.querySelectorAll(".difficulty-tabs .tab").forEach((btn) => {
          btn.addEventListener("click", () => {
            currentDifficulty = btn.dataset.level; // easy, normal, hard
            currentLevelIndex = 1; // reset to first level
            setLevel(currentSize, currentDifficulty, currentLevelIndex);

            document
              .querySelectorAll(".difficulty-tabs .tab")
              .forEach((t) => t.classList.remove("active"));
            btn.classList.add("active");
          });
        });

        function setDifficulty(diff) {
          let size;
          let givens;

          switch (diff) {
            case "easy":
              size = 4;
              givens = 10;
              break;

            case "normal":
              size = 6;
              givens = 20;
              break;

            case "hard":
              size = 9;
              givens = 34;
              break;
          }

          generateAndStartPuzzle({
            size,
            givensTarget: givens,
            uniqueness: true,
            seed: null,
          });
        }
        function syncDifficultyTab(size) {
          diffTabs.forEach((tab) => {
            const map = { easy: 4, normal: 6, hard: 9 };
            tab.classList.toggle("active", map[tab.dataset.diff] === size);
          });
        }

        // Events
        // el.btnReset.addEventListener("click", resetPuzzle);
        el.btnPause.addEventListener("click", handlePause);
        el.btnHint.addEventListener("click", hint);
        el.btnNew.addEventListener("click", newPuzzle);

        el.btnFree?.addEventListener("click", () => switchMode("free"));
        el.btnDaily?.addEventListener("click", () => switchMode("daily"));

        el.btnKM?.addEventListener("click", () => {
          lang = "km";
          applyLang();
          buildKeypad();
          buildLevelSelect();
          persist();
        });
        el.btnEN?.addEventListener("click", () => {
          lang = "en";
          applyLang();
          buildKeypad();
          buildLevelSelect();
          persist();
        });

        el.btnSound?.addEventListener("click", () => {
          const on = Sound.toggle();
          el.btnSound.innerHTML =
            (on ? "ðŸ”Š " : "ðŸ”‡ ") + `<span>${I18N[lang].sound}</span>`;
          persist();
        });

        el.btnGoLevel?.addEventListener("click", () => {
          if (mode !== "free") return;
          //   const target = parseInt(el.levelSelect.value, 10);
          setLevel(target);
        });

        el.btnWinClose.addEventListener("click", closeWin);
        el.btnWinNext.addEventListener("click", goNextAfterWin);
        el.winModal.addEventListener("click", (e) => {
          if (e.target === el.winModal) closeWin();
        });

        document.addEventListener("click", (e) => {
          const insideCell = e.target.closest && e.target.closest(".cell");
          const insideKeypad = e.target.closest && e.target.closest("#keypad");
          if (!insideCell && !insideKeypad) clearSelection();
        });

        window.addEventListener("keydown", (e) => {
          if (paused) return;
          if (el.winModal.classList.contains("show")) {
            if (e.key === "Escape") closeWin();
            return;
          }
          if (e.key >= "1" && e.key <= "9") {
            const v = parseInt(e.key, 10);
            if (v <= cfg.N) setValue(v);
          }
          if (e.key === "Backspace" || e.key === "Delete") eraseValue();
          if (e.key === "Enter") checkBoard();
          if (e.key === "h" || e.key === "H") hint();
        });

        // Init
        function init() {
          console.log("Init ...");

          timeSeconds = 0;
          paused = false;
          stopTimer();
          updateTimeUI();

          const resumed = restore();
          applyLang();

          if (!resumed) {
            currentSize = 4; // default 4x4
            currentDifficulty = "easy"; // default difficulty
            currentLevelIndex = 1; // default level
            setLevel(currentSize, currentDifficulty, currentLevelIndex);
          } else {
            // resume restored game
            setLevel(currentSize, currentDifficulty, currentLevelIndex);
          }
        }

        init();
      })();
    </script>
  </body>
</html>
